#!/usr/bin/env python3
"""Generate organisation index and dependency graph assets from repos.yml."""
from __future__ import annotations

import argparse
from pathlib import Path
from typing import Dict, List, Mapping, Sequence

import repo_config


def _as_sequence(value: object) -> List[str]:
    if not value:
        return []
    if isinstance(value, list):
        return [str(item) for item in value]
    return [str(value)]


def _bool_marker(enabled: object) -> str:
    if isinstance(enabled, bool):
        return "✅" if enabled else "–"
    if enabled in {"true", "True", "yes", "Yes", "1"}:
        return "✅"
    if enabled in {"false", "False", "no", "No", "0"}:
        return "–"
    return str(enabled) if enabled is not None else "–"


def _escape_markdown(text: str) -> str:
    return text.replace("|", "\\|")


def _ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def _sanitize_id(name: str) -> str:
    mapped = [ch if ch.isalnum() else "_" for ch in name]
    sanitized = "".join(mapped).strip("_") or "repo"
    if sanitized[0].isdigit():
        sanitized = f"repo_{sanitized}"
    return sanitized


def _node_ids(names: Sequence[str]) -> Mapping[str, str]:
    used: Dict[str, int] = {}
    mapping: Dict[str, str] = {}
    for name in names:
        base = _sanitize_id(name)
        index = used.get(base, 0)
        candidate = base if index == 0 else f"{base}_{index + 1}"
        while candidate in mapping.values():
            index += 1
            candidate = f"{base}_{index + 1}"
        used[base] = index + 1
        mapping[name] = candidate
    return mapping


def render_index(repos: Sequence[Mapping[str, object]], ordered_names: Sequence[str]) -> str:
    lines = [
        "# Org Index",
        "",
        "<!-- Generated by scripts/generate_org_assets.py; do not edit manually. -->",
        "",
        "Quelle: [`repos.yml`](../repos.yml).",
        "",
        "| Repo | Default Branch | Domain | Scope | Metrics | Depends On |",
        "| --- | --- | --- | --- | --- | --- |",
    ]
    repo_map = {str(repo["name"]): repo for repo in repos if "name" in repo}
    for name in ordered_names:
        repo = repo_map.get(name)
        if not repo:
            continue
        url = str(repo.get("url") or "")
        link = f"[{name}]({url})" if url else name
        default_branch = _escape_markdown(str(repo.get("default_branch") or "main"))
        domain = _escape_markdown(str(repo.get("domain") or "–"))
        scope = _escape_markdown(str(repo.get("scope") or "–"))
        metrics = repo.get("metrics") if isinstance(repo.get("metrics"), Mapping) else None
        metrics_marker = _bool_marker(metrics.get("enable")) if isinstance(metrics, Mapping) else _bool_marker(None)
        depends = ", ".join(sorted(_as_sequence(repo.get("depends_on")))) or "–"
        depends = _escape_markdown(depends)
        lines.append(
            f"| {link} | {default_branch} | {domain} | {scope} | {metrics_marker} | {depends} |"
        )
    lines.append("")
    return "\n".join(lines)


def render_graph(repos: Sequence[Mapping[str, object]], ordered_names: Sequence[str]) -> str:
    repo_map = {str(repo["name"]): repo for repo in repos if "name" in repo}
    ids = _node_ids(ordered_names)
    lines = [
        "%% Org dependency graph",
        "%% Generated by scripts/generate_org_assets.py; do not edit manually.",
        "graph TD",
    ]
    for name in ordered_names:
        repo = repo_map.get(name)
        if not repo:
            continue
        label_domain = str(repo.get("domain") or "–")
        label_scope = str(repo.get("scope") or "–")
        label = f"{name}\\n({label_domain} › {label_scope})"
        label = label.replace('"', "'")
        lines.append(f"    {ids[name]}[\"{label}\"]")
    for name in ordered_names:
        repo = repo_map.get(name)
        if not repo:
            continue
        for dependency in _as_sequence(repo.get("depends_on")):
            if dependency not in repo_map:
                continue
            lines.append(f"    {ids[dependency]} --> {ids[name]}")
    lines.append("")
    return "\n".join(lines)


def load_repos(path: Path) -> List[Mapping[str, object]]:
    data = repo_config.load_config(path)
    repos = repo_config.gather_repos(data)
    repos.sort(key=lambda entry: str(entry.get("name", "")))
    return repos


def determine_order(repos: Sequence[Mapping[str, object]]) -> List[str]:
    return repo_config.ordered_repo_names([dict(repo) for repo in repos])


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate Org index and graph from repos.yml")
    parser.add_argument("--repos-file", default="repos.yml", help="Path to repos.yml")
    parser.add_argument("--index", dest="index_output", help="Path to write org index markdown")
    parser.add_argument("--graph", dest="graph_output", help="Path to write org dependency mermaid graph")
    args = parser.parse_args()

    repos_path = Path(args.repos_file)
    if not repos_path.exists():
        raise SystemExit(f"repos file not found: {repos_path}")

    repos = load_repos(repos_path)
    ordered_names = determine_order(repos)

    if args.index_output:
        index_path = Path(args.index_output)
        _ensure_parent(index_path)
        index_content = render_index(repos, ordered_names)
        index_path.write_text(index_content, encoding="utf-8")

    if args.graph_output:
        graph_path = Path(args.graph_output)
        _ensure_parent(graph_path)
        graph_content = render_graph(repos, ordered_names)
        graph_path.write_text(graph_content, encoding="utf-8")


if __name__ == "__main__":
    main()
